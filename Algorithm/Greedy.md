# 탐욕 알고리즘

## 부분 집합

- 집합에 포함된 원소들을 선택하는 것

- 구현 방법
    
    1) 완전 탐색
        - Branch : 2개
        - Level : 3개
    
    2) Binary Counting : 원소 수에 해당하는 **N개의 비트열**을 이용한다.
        - 리스트를 뒤집어서 생각해야 함.
        - ex) {A, B, C}에서 001 이면 {A} 이다.
        - 부분집합의 수를 shift 연산자를 이용해서 풀 수 있다.
            - `1 << len(arr)` = 2^n

## 조합

- 서로 다른 n개의 원소 중 r개를 **순서 없이** 골라낸 것
- **n개 중 0개 조합, 1개 조합, 2개 조합, ... , n개 조합까지를 구한 것**이 부분 집합이다.
- **필요한 몇 개의 case 만**을 풀 때 사용하면 좋다.

- 구현 방법
    
    1) r중 for문
        - branch : n개
        - level : r개
    
    2) 재귀 호출 구현
        - 조합은 중복을 허용하지 않기 때문에 **이미 선택한 것을 배제**하고 재귀 호출을 해야 한다.
      
## Greedy

- 결정이 필요할 때, 현재 기준으로 **가장 좋아 보이는 선택지**로 결정하여 답을 도출하는 알고리즘
- 구현 순서

    0) 규칙성을 찾아야 한다. (규칙을 못 찾으면 못 푼다.)
    
    - 단계별로 나눠서 최적해 선택을 한다.
    
    1) 탐욕적 선택 조건 (Greedy Choice Property)

        - 각 단계의 최적해 선택이 **이후에 영향을 주지 않아야** 한다.
        - 즉, 각 단계의 규칙이 변하면 안된다.
    
    2) 최적 부분 구조 (Optimal Substructure) => 핵심!
        
        - 각 단계의 **최적해 선택을 합하면, 전체 문제의 해결책**이어야 한다.

    3) **반례** 유무 확인
