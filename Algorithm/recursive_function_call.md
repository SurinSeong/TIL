# 재귀를 활용해 순열을 생성하는 방식

- 백트래킹 방식으로 생성

- 함수

```
def f(i, N):    # 크기가 N이고 순열을 저장한 p 배열에서 p[i]를 결정하는 함수
    if i == N:
        print(p)
    else:
        for j in range(i, N):
            p[i], p[j] = p[j], p[i]    # 자리교환
            f(i+1, N)    # i+1 자리 결정
            p[i], p[j] = p[j], p[i]    # 원상 복구
```
- 추가 설명
    - i : 현재 자리 (순열의 i번째 위치를 결정하려고 한다.)
    - N : 순열의 전체 크기 (순열을 만들 배열의 길이)
    - p : 순열을 저장하는 배열
 
- 동작과정

    1. 기저 조건
        - i == N이면 순열을 다 완성한 상태  
           ==> 출력!
    
        ```
        if i == N:
            print(p)
        ```
        
    2. 재귀 탐색
        - `for j in range(i, N)` : 현재 자리 i에서 가능한 숫자들을 선택하기 위해, i부터 N-1까지 반복
        - 각 j에 대해, 자리 교환을 수행해 `p[i], p[j]`의 값을 바꾼다.
        - `f(i+1, N)`을 호출해, 그 후, i+1 번째 자리를 결정 ==> **재귀 호출**
        -  재귀가 끝난 후, **원상복구**하여 `p[i], p[j]`의 값을 다시 원래대로
      
- 재귀 호출에 대한 자세한 설명
    - `p = [1, 2, 3] (N = 3)` 순열을 구하는 과정
    - `f(0, 3)` 처음 호출

1. `f(0, 3)` 호출:
    - `i = 0, p = [1, 2, 3]`
    - j는 0 ~ 2까지 반복
    - **첫 번째 반복 (j = 0)**
        - `p[0], p[0]`을 교환하지만 변화가 없음.
        - `f(1, 3)`을 호출하여 1번째 자리를 결정함.

2. `f(1, 3)` 호출:
    - `i = 1, p = [1, 2, 3]`
    - j는 1 ~ 2까지 반복
    - **첫 번째 반복 (j = 1)**
        - `p[1], p[1]`을 교환하지만 변화가 없음.
        - `f(2, 3)`을 호출하여 2번째 자리를 결정함.
     
3. `f(2, 3)` 호출:
    - `i = 2, p = [1, 2, 3]`
    - j는 2 ~ 2까지 반복
    - **첫 번째 반복 (j = 2)**
        - `p[2], p[2]`을 교환하지만 변화가 없음.
        - `f(3, 3)`을 호출하여 순열 완성.
     
4. `f(3, 3)` 호출:
    - 완성된 순열 출력
  
5. 백트래킹
    - `f(2, 3)`으로 돌아가
