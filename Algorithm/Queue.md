# Queue (큐)

- 큐의 특성
    - 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
        - 큐의 뒤에서는 삽입만하고, 큐의 앞에서는 삭제만 이루어지는 구조
    - **선입 선출 구조** (FIFO : First In First Out)
        - 큐에 **삽입한 순서대로** 원소가 저장되어, 가장 먼저 삽입된 원소는 가장 먼저 삭제된다.
     
- 큐의 구조
    - **front** : 저장된 원소 중 첫 번째 원소 (또는 삭제 위치)
    - **rear** : 저장된 원소 중 마지막 원소

- 기본 연산
    - 삽입 : **enqueue**
    - 삭제 : **dequeue**

<details>
    <summary>주요 연산</summary>

- enQueue(item) : 큐의 뒤쪽(rear+1)에 원소를 삽입하는 연산
- deQueue() : 큐의 앞쪽(front)에서 원소를 삭제하고 반환하는 연산
- createQueue() : 공백 상태의 큐를 생성하는 연산
- isEmpty() : 큐가 공백 상태인지를 확인하는 연산
- isFull() : 큐가 포화 상태인지를 확인하는 연산
- Qpeek() : 큐의 앞쪽(front)에서 원소를 삭제없이 반환하는 연산
    
</details>


## 선형 큐

- 1차원 배열을 이용한 큐
- 큐의 크기 = 배열의 크기
- front : 저장된 첫 번째 원소의 인덱스
- rear : 저장된 마지막 원소의 인덱스

- 상태 표현
    - 초기 상태 : front = rear = -1
    - 공백 상태 : front == rear
    - 포화 상태 : rear == n-1 (n : 배열의 크기, n-1 : 배열의 마지막 인덱스)
 
### 큐의 구현

- 초기 공백 큐 생성
    - 크기 n인 1차원 배열 생성
    - front와 rear를 -1로 초기화
 
- 삽입 : **enqueue(item)**
    - 마지막 원소 뒤에 **새로운 원소를 삽입**하기 위해
 
        1) **rear 값을 하나 증가** 시켜 새로운 원소를 삽입할 자리를 마련
        2) 그 인덱스에 해당하는 배열 원소 Q[rear]에 item을 저장
     
        ```
        def enQueue(item):
          global rear
          if isFull():
              print("Queue_Full")
          else:
              rear += 1
              Q[rear] = item
        ```
      
- 삭제 : **dequeue()**
    - **가장 앞에 있는 원소를 삭제**하기 위해
 
        1) **front 값을 하나 증가**시켜 큐에 남아있는 첫 번째 원소 이동
        2) 새로운 첫 번째 원소를 리턴함으로써 삭제와 동일한 기능을 한다.

        ```
        def deQueue():
            if isEmpty():
                print("Queue_Empty")
            else:
                front += 1
                return Q[front]
        ```
     
- 공백 상태 및 포화 상태 검사 : **isEmpty()**. **isFull()**
    - 공백 상태 : front == rear
    - 포화 상태 : rear == n-1 (n: 배열의 크기, n-1: 배열의 마지막 인덱스)

    ```
    def isEmpty():
        return front == rear

    def isFull():
        return rear == len(Q) - 1
    ```
     
- 검색 : **Qpeek()**
    - 가장 앞에 있는 원소를 검색하여 반환하는 연산
    - 현재 front의 한 자리 뒤(front+1)에 있는 원소, 즉 큐의 첫 번째에 있는 원소를 반환

    ```
    def Qpeek():
        if isEmpty():
            print("Queue_Empty")
        else:
            return Q[front+1]
    ```
 
## 원형 큐

- 선형 큐 이용시의 문제점
    - 잘못된 포화상태 인식
        - 선형 큐를 이용하여 원소의 삽입과 삭제를 계속 할 경우, 배열의 앞 부분에 활용할 수 있는 공간이 있음에도 불구하고, rear=n-1인 상태 즉, 포화 상태로 인식하여 더 이상의 삽입을 수행하지 않게 된다.

- 해결 방법
    - 1차원 배열을 사용하되, 논리적으로는 **배열의 처음과 끝이 연결**되어 원형 형태의 큐를 이룬다고 가정하고 사용
 
- 문제풀이에 있어서는 항상 해답은 아니다.
    - 더 받아야 하는데 포화 상태라면, 어디에 덮어 쓸 것인지를 정해야 한다.
    - 미리 크기를 정하고 들어가면 포화상태가 나온다면 out of range가 나오기 때문에 뭐가 틀렸는지 알 수 있음.
 
### 구조

- 초기 공백 상태
    - front = rear = 0

- Index의 순환
    - front와 rear의 위치가 배열의 마지막 인덱스인 n-1을 가리킨 후, 그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동해야 함.
    - 이를 위해 나머지 연산자를 사용한다.
 
- front 변수
    - **공백 상태**와 **포화 상태** 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둔다.

- 삽입 위치 및 삭제 위치
    - rear = (rear+1) % n / front = (front+1) % n

### 구현    

- 공백 상태 및 포화 상태 검사
    - `(rear+1) % n == front`이면 포화상태이다.
    - `front == rear`이면 공백상태이다.
 
    ```
    def isEmpty():
        return front == rear

    def isFull():
        return (rear+1) % len(cQ) == front
    ```
 
- 삽입
    - 마지막 원소 뒤에 새로운 원소를 삽입하기 위해
        1) rear 값을 조정하여 새로운 원소를 삽입할 자리를 마련함 : rear = (rear + 1) % n
        2) 그 인덱스에 해당하는 배열 원소 cQ[rear]에 item을 저장

        ```
        def enQueue(item):
            global rear
            if isFull():
                print("Queue_Full")
            else:
                rear = (rear + 1) % len(cQ)
                cQ[rear] = item
        ```

- 삭제
    - 가장 앞에 있는 원소를 삭제하기 위해
        1) front 값을 조정하여 삭제할 자리를 준비한다.
        2) 새로운 front 원소를 리턴 함으로써 삭제와 동일한 기능을 한다.
     
        ```
        def dequeue():
            global front
            if isEmpty():
                print("Queue_Empty")
            else:
                front = (front + 1) % len(cQ)
                return cQ[front]
        ```

## 연결 큐

- **단순 연결 리스트**를 이용한 큐
    - 큐의 원소 : 단순 연결 리스트의 노드
    - 큐의 원소 순서 : 노드의 연결 순서. **링크(레퍼런스)로 연결**되어 있음.
    - front : 첫 번째 노드를 가리키는 링크
    - rear : 마지막 노드를 가리키는 링크
 
- 상태 표현
    - 초기 상태 : front = rear = null
    - 공백 상태 : front = rear = null
 
### 연산 과정

1. 공백 큐 생성
2. 원소 A 삽입
    - 첫 번째 노드에 메모리 할당
    - front와 rear가 A를 가리키는 레퍼런스가 된다.

3. 원소 B 삽입
    - 새로운 메모리를 받아서 front가 가리키는 노드에 저장한다.
    - rear 레퍼런스가 front가 가리키는 노드에 저장된 새로운 메모리를 가리킬 수 있도록 한다.

4. 원소 삭제
    - front가 원래 노드의 오른쪽 노드를 가리키게 되고 그 노드의 메모리를 저장한다.

### deque 덱

- **양쪽 끝에서 빠르게 추가와 삭제를 할 수 있는** 리스트류 컨테이너
- 연산
    - append(x)
    - popleft() : 왼쪽에서 요소를 제거하고 반환. 요소가 없으면 IndexError

<details>
    <summary>코드</summary>
    
```
from collections import deque

q = deque()
q.append(1)    # enqueue()
t = q.popleft()    # dequeue()
```

</details>

## 우선순위 큐 Priority Queue

- 특성
    - 우선순위를 가진 항목들을 저장하는 큐
    - FIFO 순서가 아니라 **우선순위가 높은 순서대로** 먼저 나가게 된다.
 
- 적용 분야
    - 시뮬레이션 시스템
    - 네트워크 트래픽 제어
    - 운영체제의 테스크 스케줄

- 구현
    - 배열을 이용한 우선순위 큐
    - 리스트를 이용한 우선순위 큐
 
- 기본 연산
    - 삽입
    - 삭제
 
### 배열을 이용한 우선순위 큐

-  배열 이용
    - 배열을 이용해서 자료를 저장
    - 원소를 삽입하는 과정에서 **우선순위를 비교**하여 적절한 위치에 삽입하는 구조
    - 가장 앞에 최고 우선순위의 원소가 위치하게 된다.
 
- 문제점
    - 배열을 사용하기 때문에, 삽입이나 삭제 연산이 일어날 때, 원소의 재배치가 발생한다.
    - 이에 소요되는 시간이나 메모리 낭비가 크다.
 
## 버퍼

- 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역
- 버퍼링 : 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 의미

- 버퍼의 자료구조
    - 버퍼는 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용된다.
    - 순서대로 입력/출력/전달되어야 하므로 FIFO 방식의 자료구조인 큐가 활용된다.

---

# BFS (Breadth First Search)

- 그래프를 탐색하는 방법에는 크게 두 가지가 있음.
    - 깊이 우선 탐색
    - 너비 우선 탐색
 
- **너비 우선 탐색**은 탐색 시작점의 **인접한 정점들을 먼저 모두 차례로 방문**한 후에, 방문했던 정점을 시작점으로 하여 다시 **인접한 정점들**을 차례로 방문하는 방식
- 인접한 정점들에 대해 탐색을 한 후, 차례로 다시 너비우선탐색을 진행해야 하므로, 선입 선출 형태의 자료구조인 **큐**를 활용함.

## 예제

1. **초기 상태** (중요)

   - visited 배열 초기화
   - Q 생성
   - 시작점 enqueue  

(while로 반복)  

2. A점 부터 시작

- dequeue : A
- A를 방문한 것으로 표시
- A의 인접점 enqueue

3. B로 먼저 들어간다.

4. Q가 비면 종료한다.

## 예제 2

- enqueue와 동시에 visited!

1. 초기 상태

- visited 배열 초기화
- q 생성
- 시작점 enqueue
- + q에 enqueue 되었음을 표시

2. 진행

- A를 q에 넣는다.
- A에 인접한 것들 중 방문하지 않은 곳을 enqueue 한다.
- A dequeue
- B에 인접한 것들 중 방문하지 않은 곳을 enqueue 한다.
- B dequeue
- C 확인
- dequeue
- D 확인
- dequeue
- D에 인접한 것들 중 방문하지 않는 곳을 enqueue 한다.

### 문제 활용

※ 출발점에서 어떤 정점까지 거리가 가장 짧은 것부터 탐색하는 것이다. ==> 최단 거리를 구할 때 많이 사용한다.  
※ 출발점이 두개 이상인 경우의 탐색에도 사용이 된다.  
※ 특별한 규칙이 없으면 저장된 순서로 가져오면 되지만, 문제의 조건을 잘 보고 접근해야한다. (ex. 작은 숫자 먼저)  
    인접 행렬의 경우, 숫자 순서대로 가지만, 인접 리스트의 경우는 순서를 따라가지 않는다. ==> 조건 확인 중요

