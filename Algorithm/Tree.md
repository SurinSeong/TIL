# Tree

## 개념
-  **비선형** 구조
-  원소들 간에 **1:n 관계**를 가지는 자료구조
-  원소들 간에 계층관계를 가지는 **계층형** 자료구조
-  상위 원소에서 하위 원소로 내려가면서 확장되는 **트리모양**의 구조

## 정의

- 한 개 이상의 노드로 이루어진 **유한 집합**이며 다음 조건을 만족한다.
    - 노드 중 최상위 노드를 루트라고 한다.
    - 나머지 노드들은 n개의 분리 집합 T1, ..., TN으로 분리될 수 있다.

- 이들 T1, ..., TN은 각각 하나의 트리가 되며, 루트의 부 트리라 한다.
    - 정점 (node, vertex)
    - 단말 노드 또는 잎 노드
 
## 용어 정리

- 노드 (node) : 트리의 원소
- 간선 (edge) : 노드를 연결하는 선. 부모 노드와 자식 노드를 연결
- 루트 노드 (root node) : 트리의 시작 노드
- 형제 노드 (sibling node) : 같은 부모 노드의 자식 노드들
- 조상 노드 : 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 로드들
- 서브 트리 (subtree) : 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
- 자손 노드 : 서브 트리에 있는 하위 레벨의 노드
- 차수 (degree)
    - 노드의 차수 : 노드에 연결된 자식 노드의 수
    - 트리의 차수 : 트리에 있는 노드의 차수 중 가장 큰 값
    - 단말 노드 (leaf node) : 차수가 0인 노드. **자식 노드가 없는 노드**
- 높이
    - 노드의 높이 : 루트에서 노드에 이르는 간선의 수. 노드의 **레벨**
    - 트리의 높이 : 트리에 있는 노드의 높이 중 **가장 큰 값**. 최대 레벨
    - 예시
        - 레벨 0 : 높이 0
        - 레벨 1 : 높이 1
        - 레벨 2 : 높이 2

## 이진 트리

- 모든 노드들이 2개 이내의 서브트리를 갖는 특별한 형태의 트리
- 각 노드가 자식 노드를 최대한 2개까지만 가질 수 있는 트리
    - 왼쪽 자식 노드 (left child node)
    - 오른쪽 자식 노드 (right child node)

### 특성

- 레벨 i에서의 노드의 개수는 최대 2^i개
- 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 (h+1)개가 되며, 최대 개수는 (2^(h+1)-1)개가 된다.

### 종류

1. 포화 이진 트리 (Full Binary Tree)

- 모든 레벨에 노드가 포화 상태로 차 있는 이진 트리
- 높이가 h일 때, 최대의 노드 개수인 (2^(h+1)-1)의 노드를 가진 이진 트리
    - 높이가 3일 때, 2^(3+1)-1개의 노드
- **루트를 1번**으로 하여, 2^(h+1)-1까지 정해진 위치에 대한 노드 번호를 가짐.

2. 완전 이진 트리 (Complete Binary Tree) (***)

- 높이가 h이고 노드 수가 n개 일 때, 포화 이진 트리의 노드 번호 1번 부터 n번까지 빈 자리가 없는 이진 트리

3. 편향 이진 트리 (Skewed Binary Tree)

- 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리

### 순회 Traversal

- 트리의 각 노드를 중복되지 않게 전부 방문하는 것을 말한다. (트리의 노드들을 **체계적으로 방문**하는 것)
- 비선형 구조이기 때문에 선형 구조에서와 같이 선후 연결 관계를 알 수 없음.
- 반드시 root에서 시작하는 것은 아니다. 하지만 순회 시작 노드를 루트로 하는 서브트리 안에서 순회를 하고 끝낸다.

- 3가지의 기본적인 순회방법
    - **전위 순회** : VLR

        - 부모 노드 방문 후, 자식 노드를 좌우 순서로 방문

            1. 현재 노드 n을 방문하여 처리
            2. 현재 노드 n의 왼쪽 서브트리로 이동함. (없으면 돌아오고, 있으면 계속 이동)
            3. 현재 노드 n의 오른쪽 서브트리로 이동함. (없으면 돌아오고, 있으면 계속 이동)
        
        <details>
            <summary>알고리즘</summary>
            
        ```python
        def preorder_traverse(T):    # 전위 순회
            if T:
                visit(T)
                preorder_travers(T.left)
                preorder_travers(T.right)
        ```
      
        </details>
        
    - **중위 순회** : LVR
        - 왼쪽 자식 노드, 부모 노드, 오른쪽 자식 노드 순으로 방문

            1. 현재 노드 n의 왼쪽 서브트리로 이동한다.
            2. 현재 노드 n을 방문하여 처리한다.
            3. 현재 노드 n의 오른쪽 서브트리로 이동한다.
         
        <details>
            <summary>알고리즘</summary>
            
        ```python
        def inorder_traverse(T):    # 중위 순회
            if T:
                preorder_travers(T.left)
                visit(T)
                preorder_travers(T.right)
        ```
      
        </details>
        
    - **후위 순회** : LRV
        - 자식 노드를 좌우 순서로 방문한 후, 부모 노드로 방문
     
            1. 현재 노드 n의 왼쪽 서브트리로 이동한다.
            2. 현재 노드 n의 오른쪽 서브트리로 이동한다.
            3. 현재 노드 n을 방문하여 처리한다.
         
        <details>
            <summary>알고리즘</summary>
            
        ```python
        def postorder_traverse(T):    # 후위 순회
            if T:
                preorder_travers(T.left)
                preorder_travers(T.right)
                visit(T)
        ```
      
        </details>
