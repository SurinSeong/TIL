# Tree

## 개념
-  **비선형** 구조
-  원소들 간에 **1:n 관계**를 가지는 자료구조
-  원소들 간에 계층관계를 가지는 **계층형** 자료구조
-  상위 원소에서 하위 원소로 내려가면서 확장되는 **트리모양**의 구조

## 정의

- 한 개 이상의 노드로 이루어진 **유한 집합**이며 다음 조건을 만족한다.
    - 노드 중 최상위 노드를 루트라고 한다.
    - 나머지 노드들은 n개의 분리 집합 T1, ..., TN으로 분리될 수 있다.

- 이들 T1, ..., TN은 각각 하나의 트리가 되며, 루트의 부 트리라 한다.
    - 정점 (node, vertex)
    - 단말 노드 또는 잎 노드
 
## 용어 정리

- 노드 (node) : 트리의 원소
- 간선 (edge) : 노드를 연결하는 선. 부모 노드와 자식 노드를 연결
- 루트 노드 (root node) : 트리의 시작 노드
- 형제 노드 (sibling node) : 같은 부모 노드의 자식 노드들
- 조상 노드 : 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 로드들
- 서브 트리 (subtree) : 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
- 자손 노드 : 서브 트리에 있는 하위 레벨의 노드
- 차수 (degree)
    - 노드의 차수 : 노드에 연결된 자식 노드의 수
    - 트리의 차수 : 트리에 있는 노드의 차수 중 가장 큰 값
    - 단말 노드 (leaf node) : 차수가 0인 노드. **자식 노드가 없는 노드**
- 높이
    - 노드의 높이 : 루트에서 노드에 이르는 간선의 수. 노드의 **레벨**
    - 트리의 높이 : 트리에 있는 노드의 높이 중 **가장 큰 값**. 최대 레벨
    - 예시
        - 레벨 0 : 높이 0
        - 레벨 1 : 높이 1
        - 레벨 2 : 높이 2

## 이진 트리

- 모든 노드들이 2개 이내의 서브트리를 갖는 특별한 형태의 트리
- 각 노드가 자식 노드를 최대한 2개까지만 가질 수 있는 트리
    - 왼쪽 자식 노드 (left child node)
    - 오른쪽 자식 노드 (right child node)

### 특성

- 레벨 i에서의 노드의 개수는 최대 2^i개
- 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 (h+1)개가 되며, 최대 개수는 (2^(h+1)-1)개가 된다.

### 종류

1. 포화 이진 트리 (Full Binary Tree)

- 모든 레벨에 노드가 포화 상태로 차 있는 이진 트리
- 높이가 h일 때, 최대의 노드 개수인 (2^(h+1)-1)의 노드를 가진 이진 트리
    - 높이가 3일 때, 2^(3+1)-1개의 노드
- **루트를 1번**으로 하여, 2^(h+1)-1까지 정해진 위치에 대한 노드 번호를 가짐.

2. 완전 이진 트리 (Complete Binary Tree) (***)

- 높이가 h이고 노드 수가 n개 일 때, 포화 이진 트리의 노드 번호 1번 부터 n번까지 빈 자리가 없는 이진 트리

3. 편향 이진 트리 (Skewed Binary Tree)

- 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리

### 순회 Traversal

- 트리의 각 노드를 중복되지 않게 전부 방문하는 것을 말한다. (트리의 노드들을 **체계적으로 방문**하는 것)
- 비선형 구조이기 때문에 선형 구조에서와 같이 선후 연결 관계를 알 수 없음.
- 반드시 root에서 시작하는 것은 아니다. 하지만 순회 시작 노드를 루트로 하는 서브트리 안에서 순회를 하고 끝낸다.

- 3가지의 기본적인 순회방법
    - **전위 순회** : VLR

        - 부모 노드 방문 후, 자식 노드를 좌우 순서로 방문

            1. 현재 노드 n을 방문하여 처리
            2. 현재 노드 n의 왼쪽 서브트리로 이동함. (없으면 돌아오고, 있으면 계속 이동)
            3. 현재 노드 n의 오른쪽 서브트리로 이동함. (없으면 돌아오고, 있으면 계속 이동)
        
        <details>
            <summary>알고리즘</summary>
            
        ```python
        def preorder_traverse(T):    # 전위 순회
            if T:
                visit(T)
                preorder_travers(T.left)
                preorder_travers(T.right)
        ```
      
        </details>
        
    - **중위 순회** : LVR
        - 왼쪽 자식 노드, 부모 노드, 오른쪽 자식 노드 순으로 방문

            1. 현재 노드 n의 왼쪽 서브트리로 이동한다.
            2. 현재 노드 n을 방문하여 처리한다.
            3. 현재 노드 n의 오른쪽 서브트리로 이동한다.
         
        <details>
            <summary>알고리즘</summary>
            
        ```python
        def inorder_traverse(T):    # 중위 순회
            if T:
                preorder_travers(T.left)
                visit(T)
                preorder_travers(T.right)
        ```
      
        </details>
        
    - **후위 순회** : LRV
        - 자식 노드를 좌우 순서로 방문한 후, 부모 노드로 방문
     
            1. 현재 노드 n의 왼쪽 서브트리로 이동한다.
            2. 현재 노드 n의 오른쪽 서브트리로 이동한다.
            3. 현재 노드 n을 방문하여 처리한다.
         
        <details>
            <summary>알고리즘</summary>
            
        ```python
        def postorder_traverse(T):    # 후위 순회
            if T:
                preorder_travers(T.left)
                preorder_travers(T.right)
                visit(T)
        ```
      
        </details>

### 표현

- **배열**을 이용한 이진 트리의 표현
    - **노드 번호**를 **배열의 인덱스**로 사용
    - 루트의 번호를 1로 함.
    - 레벨 n에 있는 노드에 대하여 왼쪽부터 오른쪽으로 2^n부터 2^(n+1)-1까지 번호를 차례로 부여
    - **포화 이진 트리**, **완전 이진 트리**에 적합

    - 노드 번호의 성질
        - 노드 번호가 i인 노드의 부모 노드 번호?    i//2
        - 노드 번호가 i인 노드의 왼쪽 자식 노드 번호?    2*i
        - 노드 번호가 i인 노드의 오른쪽 자식 노드 번호?    2*i+1
        - 레벨 n의 노드 시작 번호는?    2**n

    - 저장
        1. 부모 번호를 인덱스로 자식 번호를 저장한다.
            - 1차원 배열 2개가 필요함. (부모를 기준으로 자식은 2개 이하)
            - 왼쪽 오른쪽으로 이동할 때 사용한다.
        
        2. 자식 번호를 인덱스로 부모 번호를 저장한다.
            - 1차원 배열 1개가 필요함. (자식을 기준을 자식은 1개 이하)
            - 조상을 찾을 때 사용한다. (루트는 부모가 없음)

    - 단점
        - 편향 이진 트리의 경우, 사용하지 않는 배열 원소에 대한 메모리 공간 낭비 발생
        - 트리의 중간에 새로운 노드를 삽입하거나 기존의 노드를 삭제할 경우, 배열의 크기 변경이 어려워 비효율적
     
- **연결 리스트**를 이용한 이진 트리의 표현
    - 이진 트리의 모든 노드는 최대 2개의 자식 노드를 가지므로 일정한 구조의 단순 연결리스트 노드를 사용하여 구현

## 이진 탐색 트리 (Binary Search Tree)

- 탐색 작업을 **효율적**으로 하기 위한 자료 구조
- 모든 원소는 **서로 다른 유일한 키**를 갖는다.
- key (왼쪽 서브 트리) < key (루트 노드) < key (오른쪽 서브 트리)
- 왼쪽 서브 트리와 오른쪽 서브 트리도 이진 탐색 트리다.
- **중위 순회**하면 **오름차순**으로 정렬된 값을 얻을 수 있다.

### 연산

<details>
    <summary>탐색 연산</summary>

- 루트에서 시작한다.
- **탐색할 키 값 x를 루트 노드의 키 값과 비교**한다.
    - (키 값 x = 루트 노드의 키 값)인 경우 : 원하는 원소를 찾았으므로 탐색연산 성공
    - (키 값 x < 루트 노드의 키 값)인 경우 : 루트 노드의 왼쪽 서브 트리에 대해서 탐색 연산 수행
    - (키 값 x > 루트 노드의 키 값)인 경우 : 루트 노드의 오른쪽 서브 트리에 대해서 탐색 연산 수행

- 서브트리에 대해서 **순환적**으로 탐색 연산을 반복한다.
    
</details>

<details>
    <summary>삽입 연산</summary>

- 먼저 탐색 연산을 수행한다.
    - 삽입할 원소와 같은 원소가 트리에 있으면 삽입할 수 없으므로, **같은 원소가 트리에 있는지 탐색하여 확인**한다.
    - 탐색에서 **탐색 실패가 결정되는 위치가 삽입 위치**가 된다.

- 탐색 실패한 위치에 원소를 삽입한다.
    
</details>

### 성능

- **탐색, 삽입, 삭제 시간**은 트리의 **높이** 만큼 시간이 걸린다.
    - O(h), h : BST의 깊이

- **평균**의 경우
    - 이진 트리가 균형적으로 생성되어 있는 경우
    - O(logn)

- 최악의 경우
    - 한쪽으로 치우친 경사 이진트리의 경우
    - O(n)
    - 순차 탐색과 시간 복잡도가 같음.

## 힙 (Heap)

- **완전 이진 트리**에 있는 노드 중에서 **키 값이 가장 큰 노드**나 **키 값이 가장 작은 노드**를 찾기 위해서 만든 자료 구조
- 최대 힙 (max heap)
    - 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
    - 부모 노드의 키 값 > 자식 노드의 키 값
    - 루트 노드 : 키 값이 가장 큰 노드

- 최소 힙 (min heap)
    - 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리
    - 부모 노드의 키 값 < 자식 노드의 키 값
    - 루트 노드 : 키 값이 가장 작은 노드

- 완전 이진 트리인 경우, **정점 번호를 인덱스로 해서 값을 넣어주면 된다.**

- 힙의 키를 우선순위로 활용해 **우선순위 큐**를 구현할 수 있음.
- **루트 노드**를 활용한다!
